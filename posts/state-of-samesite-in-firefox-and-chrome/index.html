<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>State of SameSite cookies in Firefox and Chromium | blog.nerd.rocks</title><meta name=keywords content="SameSite,Firefox,Chromium,CSRF"><meta name=description content="SameSite cookies are commonly used to harden websites against CSRF attacks. These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with the SameSite attribute set to strict should not be send to the destination site, if the request passed a foreign site. However, handling of the SameSite attribute differs between Firefox and Chromium.
What is the SameSite attribute in theory? The SameSite attribute was specified in the RFC draft rfc6265bis."><meta name=author content><link rel=canonical href=https://blog.nerd.rocks/posts/state-of-samesite-in-firefox-and-chrome/><link crossorigin=anonymous href=/assets/css/stylesheet.706230b2c01b2f9cec39f070771415c37f76ed4d690dae0d9f25fa66dfb55d9e.css integrity="sha256-cGIwssAbL5zsOfBwdxQVw3927U1pDa4NnyX6Zt+1XZ4=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.nerd.rocks/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.nerd.rocks/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.nerd.rocks/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.nerd.rocks/apple-touch-icon.png><link rel=mask-icon href=https://blog.nerd.rocks/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="State of SameSite cookies in Firefox and Chromium"><meta property="og:description" content="SameSite cookies are commonly used to harden websites against CSRF attacks. These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with the SameSite attribute set to strict should not be send to the destination site, if the request passed a foreign site. However, handling of the SameSite attribute differs between Firefox and Chromium.
What is the SameSite attribute in theory? The SameSite attribute was specified in the RFC draft rfc6265bis."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.nerd.rocks/posts/state-of-samesite-in-firefox-and-chrome/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-12T20:29:02+01:00"><meta property="article:modified_time" content="2023-03-12T20:29:02+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="State of SameSite cookies in Firefox and Chromium"><meta name=twitter:description content="SameSite cookies are commonly used to harden websites against CSRF attacks. These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with the SameSite attribute set to strict should not be send to the destination site, if the request passed a foreign site. However, handling of the SameSite attribute differs between Firefox and Chromium.
What is the SameSite attribute in theory? The SameSite attribute was specified in the RFC draft rfc6265bis."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.nerd.rocks/posts/"},{"@type":"ListItem","position":2,"name":"State of SameSite cookies in Firefox and Chromium","item":"https://blog.nerd.rocks/posts/state-of-samesite-in-firefox-and-chrome/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"State of SameSite cookies in Firefox and Chromium","name":"State of SameSite cookies in Firefox and Chromium","description":"SameSite cookies are commonly used to harden websites against CSRF attacks. These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with the SameSite attribute set to strict should not be send to the destination site, if the request passed a foreign site. However, handling of the SameSite attribute differs between Firefox and Chromium.\nWhat is the SameSite attribute in theory? The SameSite attribute was specified in the RFC draft rfc6265bis.","keywords":["SameSite","Firefox","Chromium","CSRF"],"articleBody":"SameSite cookies are commonly used to harden websites against CSRF attacks. These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with the SameSite attribute set to strict should not be send to the destination site, if the request passed a foreign site. However, handling of the SameSite attribute differs between Firefox and Chromium.\nWhat is the SameSite attribute in theory? The SameSite attribute was specified in the RFC draft rfc6265bis. It can be used with three different enforcement modes RFC6265bis#section-5.5.7.1: none, strict and lax.\nnone disables the SameSite enforcement such that cookies are also sent when the request is invoked by a cross site. strict enforces the cookie only to be sent when it is a same site request. Therefore the cookie is only sent, when the site was requested by entering the url manually in the url bar of the browser or navigating on the same domain. lax is not as strict as the strict mode since it allows to sent cookies in a request that is invoked by a cross site when it uses a safe http method. Http methods are considered safe if their semantic is defined as read-only (RFC7231#section-4.2.1). In order to separate a same site request from a cross site request, the RFC introduces an algorithm in section 5.2. To conclude the algorithm, one can say, that every request, that is not initiated by hand(by entering the url manually) or by the exact match of the referring domain, is cross site. Every other request is a same site request.\nPractical behavior in Firefox and Chromium For testing the behavior of Firefox and Chromium I’ve implemented a website, that sets three cookies, is able to display them and is able to redirect manually, as well as automatically. Each of three cookies have the SameSite attribute set to none, lax and strict. The website is able to perform the role of both sites, since it is able to perform the redirect on both ways. Therefore the application will be started twice in a docker container with a static ip address: 10.5.0.2 and 10.5.0.3. This is important since it enforces another target address for the redirect.\nAfter starting the docker container, we are able to open the first site in our first browser we are testing - Firefox 110.0.1 on linux. Then we click on “Set the cookies” in order to set all three cookies. As one can see in the screenshot, they are set correctly. Next to Firefox you are also able to see, that they are set in Chromium 111.0.5563.64 on linux.\nNext we click on “Invoke manual redirect for testing” in both browsers. This will redirect the browser to 10.5.0.3. There we do not see any cookies, as we did not set them. If we then click on “Invoke manual redirect for testing” again, we are redirected back to 10.5.0.2 and are able to see only the cookies without the SameSite-attribute set to strict, which behaves exactly like the RFC described it before.\nIn our next test we will perform an automatic redirect. To reset the scenario, we click on “Delete cookies” and “Set the cookies”, which leads to the same page as in the first screenshot. After resetting the scenario, we click on “Invoke the redirect for testing”. This will automatically redirect to 10.5.0.3 and the back to 10.5.0.2. Hence the algorithm for determining a same site request states out that every URL in the redirect must be the same as the origin for a same site request, we expect to not see the cookie with the SameSite-attribute set to strict as well. However, Chromium is sending the cookie along with the request. Firefox, in contrast, is behaving correctly.\nPotential attack surface Some sites allow users to be redirected by a given URL as a query parameter, e.g. when you enter the URL to a restricted area without authentication and the destination URL is stored as a query parameter on the login page. If these redirects are used, even if they are bad practice, and allow redirects to external sites, cookies with SameSite set to strict will not mitigate CSRF attacks in Chromium.\nIn detail, an attacker would the an example URL to the victim like https://vuln.erable/login?to=https://att.acker. This would show the login site of the vulnerable site to the victim, who then enters the credentials. The vulnerable site then sends the cookie containing the session with SameSite set to strict back to the browser and invokes then the redirect to the attacking site via HTTP- or JS- redirect. The attacking site will then create some malicous redirect, which might extract some information or controls some aspects in the vulnerable site. This redirect is the performed by the browser. Firefox will drop the session cookie due to the SameSite attribute and will therefore break the session, such that the exploit would be mitigated in the first place. Chromium however will not drop the session cookie as shown in the lab setup before. Therefore the exploit would be successful.\nConclusion Firefox and Chromium handle the SameSite attribute with enforcment mode strict quite different in terms of redirects. On automatic redirects, Chromium will not drop the cookie, in contrast to the specification. However, the potential attack surface is quite limited and requires bad practices and other flaws in the web application. Therefore one should be aware of the different behavior and not only rely on a single countermeasure against certain attacks. The mitigation should always be validated in certain scenarios.\n","wordCount":"918","inLanguage":"en","datePublished":"2023-03-12T20:29:02+01:00","dateModified":"2023-03-12T20:29:02+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nerd.rocks/posts/state-of-samesite-in-firefox-and-chrome/"},"publisher":{"@type":"Organization","name":"blog.nerd.rocks","logo":{"@type":"ImageObject","url":"https://blog.nerd.rocks/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.nerd.rocks accesskey=h title="blog.nerd.rocks (Alt + H)">blog.nerd.rocks</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://blog.nerd.rocks/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.nerd.rocks/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.nerd.rocks/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">State of SameSite cookies in Firefox and Chromium</h1><div class=post-meta><span title='2023-03-12 20:29:02 +0100 +0100'>2023-03-12</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-the-samesite-attribute-in-theory aria-label="What is the SameSite attribute in theory?">What is the SameSite attribute in theory?</a></li><li><a href=#practical-behavior-in-firefox-and-chromium aria-label="Practical behavior in Firefox and Chromium">Practical behavior in Firefox and Chromium</a></li><li><a href=#potential-attack-surface aria-label="Potential attack surface">Potential attack surface</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>SameSite cookies are commonly used to harden websites against CSRF attacks.
These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with
the SameSite attribute set to <em>strict</em> should not be send to the destination
site, if the request passed a foreign site. However, handling of the SameSite
attribute differs between Firefox and Chromium.</p><h3 id=what-is-the-samesite-attribute-in-theory>What is the SameSite attribute in theory?<a hidden class=anchor aria-hidden=true href=#what-is-the-samesite-attribute-in-theory>#</a></h3><p>The SameSite attribute was specified in the RFC draft <a href=https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-11>rfc6265bis</a>.
It can be used with three different enforcement modes <a href=https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-11#name-strict-and-lax-enforcement>RFC6265bis#section-5.5.7.1</a>: <em>none</em>, <em>strict</em> and <em>lax</em>.</p><ul><li><em>none</em> disables the SameSite enforcement such that cookies are also sent when the request is invoked by a cross site.</li><li><em>strict</em> enforces the cookie only to be sent when it is a same site request. Therefore the cookie is only sent, when the site was requested by entering the url manually in the url bar of the browser or navigating on the same domain.</li><li><em>lax</em> is not as strict as the <em>strict</em> mode since it allows to sent cookies in a request that is invoked by a cross site when it uses a safe http method. Http methods are considered safe if their semantic is defined as read-only (<a href=https://tools.ietf.org/html/rfc7231#section-4.2.1>RFC7231#section-4.2.1</a>).</li></ul><p>In order to separate a same site request from a cross site request, the RFC introduces an algorithm in <a href=https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-11#name-same-site-and-cross-site-re>section 5.2</a>.
To conclude the algorithm, one can say, that every request, that is not initiated by hand(by entering the url manually) or by the exact match of the referring domain, is cross site.
Every other request is a same site request.</p><h3 id=practical-behavior-in-firefox-and-chromium>Practical behavior in Firefox and Chromium<a hidden class=anchor aria-hidden=true href=#practical-behavior-in-firefox-and-chromium>#</a></h3><p>For testing the behavior of Firefox and Chromium I&rsquo;ve implemented a website, that
sets three cookies, is able to display them and is able to redirect manually, as
well as automatically. Each of three cookies have the SameSite attribute set to
<em>none</em>, <em>lax</em> and <em>strict</em>. The website is able to perform the role of both sites,
since it is able to perform the redirect on both ways. Therefore the application
will be started twice in a docker container with a static ip address: 10.5.0.2 and
10.5.0.3. This is important since it enforces another target address for the
redirect.</p><p>After starting the docker container, we are able to open the first site in our
first browser we are testing - Firefox 110.0.1 on linux. Then we click on
&ldquo;Set the cookies&rdquo; in order to set all three cookies. As one can see in the
screenshot, they are set correctly. Next to Firefox you are also able to see,
that they are set in Chromium 111.0.5563.64 on linux.</p><p><img loading=lazy src=/img/state-of-same-site-cookies-in-firefox-and-chromium/initial.png alt="inital setup"></p><p>Next we click on &ldquo;Invoke manual redirect for testing&rdquo; in both browsers. This will
redirect the browser to 10.5.0.3. There we do not see any cookies, as we did not
set them. If we then click on &ldquo;Invoke manual redirect for testing&rdquo; again, we are
redirected back to 10.5.0.2 and are able to see only the cookies without the
SameSite-attribute set to <em>strict</em>, which behaves exactly like the RFC described
it before.</p><p><img loading=lazy src=/img/state-of-same-site-cookies-in-firefox-and-chromium/manual.png alt="manual redirect"></p><p>In our next test we will perform an automatic redirect. To reset the scenario,
we click on &ldquo;Delete cookies&rdquo; and &ldquo;Set the cookies&rdquo;, which leads to the same page
as in the first screenshot. After resetting the scenario, we click on
&ldquo;Invoke the redirect for testing&rdquo;. This will automatically redirect to 10.5.0.3
and the back to 10.5.0.2. Hence the algorithm for determining a same site request
states out that every URL in the redirect must be the same as the origin for a
same site request, we expect to not see the cookie with the SameSite-attribute set
to <em>strict</em> as well. However, Chromium is sending the cookie along with the request.
Firefox, in contrast, is behaving correctly.</p><p><img loading=lazy src=/img/state-of-same-site-cookies-in-firefox-and-chromium/automatic.png alt="automatic redirect"></p><h3 id=potential-attack-surface>Potential attack surface<a hidden class=anchor aria-hidden=true href=#potential-attack-surface>#</a></h3><p>Some sites allow users to be redirected by a given URL as a query parameter, e.g.
when you enter the URL to a restricted area without authentication and the destination
URL is stored as a query parameter on the login page. If these redirects are used, even
if they are bad practice, and allow redirects to external sites, cookies with SameSite
set to <em>strict</em> will not mitigate CSRF attacks in Chromium.</p><p>In detail, an attacker would the an example URL to the victim like <a href="https://vuln.erable/login?to=https://att.acker">https://vuln.erable/login?to=https://att.acker</a>. This would show the login site of
the vulnerable site to the victim, who then enters the credentials. The vulnerable
site then sends the cookie containing the session with SameSite set to <em>strict</em> back
to the browser and invokes then the redirect to the attacking site via HTTP- or JS-
redirect. The attacking site will then create some malicous redirect, which might
extract some information or controls some aspects in the vulnerable site. This redirect
is the performed by the browser. Firefox will drop the session cookie due to the
SameSite attribute and will therefore break the session, such that the exploit
would be mitigated in the first place. Chromium however will not drop the session
cookie as shown in the lab setup before. Therefore the exploit would be successful.</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>Firefox and Chromium handle the SameSite attribute with enforcment mode <em>strict</em>
quite different in terms of redirects. On automatic redirects, Chromium will not
drop the cookie, in contrast to the specification. However, the potential attack surface
is quite limited and requires bad practices and other flaws in the web application.
Therefore one should be aware of the different behavior and not only rely on a single
countermeasure against certain attacks. The mitigation should always be validated
in certain scenarios.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.nerd.rocks/tags/samesite/>SameSite</a></li><li><a href=https://blog.nerd.rocks/tags/firefox/>Firefox</a></li><li><a href=https://blog.nerd.rocks/tags/chromium/>Chromium</a></li><li><a href=https://blog.nerd.rocks/tags/csrf/>CSRF</a></li></ul><nav class=paginav><a class=prev href=https://blog.nerd.rocks/posts/profiling-zellij-plugins/><span class=title>« Prev</span><br><span>Learnings from developing a zellij plugin</span></a>
<a class=next href=https://blog.nerd.rocks/posts/debugging-another-sigabrt-in-neovim/><span class=title>Next »</span><br><span>Debugging another SIGABRT in neovim</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.nerd.rocks>blog.nerd.rocks</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>