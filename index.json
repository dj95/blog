[{"content":"This page describes some common tasks and snippets that can be used for the plugin development. Snippets are written in Rust, but the concepts should be transferable to other languages as well. All examples are based on the rust-plugin-example.\nNon selectable plugins with permissions If a plugin (like a statusbar) should be non selectable, zellij-tile provides the function set_selectable(). When this function is directly called on plugin initialization, a user won\u0026rsquo;t be able to grant plugin permissions since the plugin cannot be selected. Therefore the plugin should call set_selectable(false) after receiving the PermissionRequestResult.\nThe following code demonstrates the feature. Notice, that the plugin must subscribe to the PermissionRequestResult to receive it in the load() function. Then the event must be handled in the update() function.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 impl ZellijPlugin for State { fn load(\u0026amp;mut self, configuration: BTreeMap\u0026lt;String, String\u0026gt;) { request_permission(\u0026amp;[ PermissionType::ReadApplicationState, ]); subscribe(\u0026amp;[ EventType::ModeUpdate, EventType::PermissionRequestResult, ]); } fn update(\u0026amp;mut self, event: Event) -\u0026gt; bool { let mut should_render = false; match event { // ... Event::PermissionRequestResult(result) =\u0026gt; { set_selectable(false); } // ... } should_render } } Queuing events until PermissionsRequestResult is received Hence Zellij communicates via events with the plugin, a plugin needs to ensure that dependencies between these events, that are relevant for the logic of the plugin, are handled correctly. For example, when a plugin is started a second time, it will receive a few events (like ModeUpdate) before the PermissionRequestResult event is received. If a plugin calls a function as soon as the ModeUpdate event is received, that requires permissions, the function call would fail. Therefore the plugin needs to hold back events until the PermissionRequestResult is received.\nThe following code demonstrates how events can be stored into a queue, until the PermissionRequestResult is received. A Vec\u0026lt;Event\u0026gt; is used in the State struct for storing the events. Event handling is extracted into a separate function, such that it can be called in several places in the update() function. If PermissionRequestResult is not received, events will be pushed into the vector. As soon as the PermissionRequestResult is received, the vector will be emptied and all events will be processed sequentially.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 struct State { pending_events: Vec\u0026lt;Event\u0026gt;, got_permissions: bool, } impl ZellijPlugin for State { // ... fn update(\u0026amp;mut self, event: Event) -\u0026gt; bool { if let Event::PermissionRequestResult(PermissionStatus::Granted) = event { self.got_permissions = true; // iterate through all cached events, if the PermissionRequestResult is // received and permissions are granted with it while !self.pending_events.is_empty() { let ev = self.pending_events.pop(); self.handle_event(ev.unwrap()); } } if !self.got_permissions { // store events in a vector until permissions were granted self.pending_events.push(event); return false; } // handle events normally, if permissions were granted self.handle_event(event) } // ... } impl State { // this function was previously the update() function fn handle_event(\u0026amp;mut self, event: Event) -\u0026gt; bool { let mut should_render = false; match event { Event::ModeUpdate(mouse_info) =\u0026gt; { should_render = true; } } should_render } } Advanced logging \u0026amp; Tracing Tracing is a form of logging, which could help to trace calls through certain functions and files of the code. There is a tracing and a tracing-subscriber, which can be utilized to implement tracing within Zellij plugins. First add these two crates with cargo add tracing tracing-subscriber.\nNext add a function, that initializes the tracing.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fn init_tracing() { use std::fs::File; use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt}; let file = File::create(\u0026#34;.zellij_plugin.log\u0026#34;); let file = match file { Ok(file) =\u0026gt; file, Err(error) =\u0026gt; panic!(\u0026#34;Error: {:?}\u0026#34;, error), }; let debug_log = tracing_subscriber::fmt::layer().with_writer(Arc::new(file)); tracing_subscriber::registry().with(debug_log).init(); tracing::info!(\u0026#34;tracing initialized\u0026#34;); } Call this function at the beginning of the load() function of your plugin. It will initialize the tracing crate and configure it, such that it will write into a log file, where the plugin is started. Then you can use the tracing crate, similarly to the log crate.\n1 2 3 4 tracing::debug!(\u0026#34;tracing initialized\u0026#34;); tracing::info!(\u0026#34;tracing initialized\u0026#34;); tracing::warning!(\u0026#34;tracing initialized\u0026#34;); tracing::error!(\u0026#34;tracing initialized\u0026#34;); Additionally, functions can be instrumented with tracing. For more details, please visit the documentation of the tracing crate at https://docs.rs/tracing/latest/tracing/.\n1 2 3 4 5 #[tracing::instrument] fn my_function() { // ... tracing::debug!(\u0026#34;some tracing output\u0026#34;); } ","permalink":"https://blog.nerd.rocks/posts/common-snippets-for-zellij-development/","summary":"\u003cp\u003eThis page describes some common tasks and snippets that can be used for the plugin development. Snippets are written in Rust,\nbut the concepts should be transferable to other languages as well. All examples are based on the \u003ca href=\"https://github.com/zellij-org/rust-plugin-example\"\u003erust-plugin-example\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"non-selectable-plugins-with-permissions\"\u003eNon selectable plugins with permissions\u003c/h2\u003e\n\u003cp\u003eIf a plugin (like a statusbar) should be non selectable, \u003ca href=\"https://docs.rs/zellij-tile/latest/zellij_tile/\"\u003ezellij-tile\u003c/a\u003e\nprovides the function \u003ccode\u003eset_selectable()\u003c/code\u003e. When this function is directly called on plugin\ninitialization, a user won\u0026rsquo;t be able to grant plugin permissions since the plugin cannot be\nselected. Therefore the plugin should call \u003ccode\u003eset_selectable(false)\u003c/code\u003e after receiving the \u003ccode\u003ePermissionRequestResult\u003c/code\u003e.\u003c/p\u003e","title":"Common snippets for developing Zellij plugins"},{"content":"This guide will help you get started with developing a plugin for Zellij in Rust. It will guide you through setting up your development environment, creating a new plugin, and playing around to understand how Zellij plugins work.\nRequirements Make sure you have the following programs installed on your system:\nRust with the wasm32-wasi target or rustup Zellij If you have installed rustup, you can install the wasm32-wasi target by running:\n1 rustup target add wasm32-wasi Plugin template The easiest way to get started is to check out the rust-plugin-example. It provides a good starting point with some basic functionality, which helps to explore the plugin development process. Navigate to the path you want to store the plugin and run:\n1 git clone https://github.com/zellij-org/rust-plugin-example After cloning the repository, navigate to the rust-plugin-example directory and build the plugin for the first time:\n1 2 cd ./rust-plugin-example cargo build This will create a target directory with the compiled plugin. It can be found at target/wasm32-wasi/debug/rust-plugin-example.wasm. To execute the plugin, use the following command:\n1 zellij action start-or-reload-plugin file:target/wasm32-wasi/debug/rust-plugin-example.wasm Now a new pane should be created, that asks for permissions. Navigate to the new pane and press y to grant the permissions. Afterwards it should display some details about the current session, like the count of columns and rows, or the current tabs.\nWhen developing the plugin, simply rebuild it with the cargo build command and then run the zellij action start-or-reload-plugin command again to reload it.\nExploring the plugin The example plugin consists mainly of the src/main.rs file, which contains the logic for it. In the file there is a struct State that implements the ZellijPlugin trait. This trait is required for Zellij to load and run the plugin. A detailed documentation of the trait can be found in Plugin Lifecycle.\nTo further play around and understand the plugin, we could in the first step implement some log output, which gives us insights into the running code. Logs are written to STDERR and captured by Zellij. Zellij will print the in its own log file. This one can be found on Linux at /tmp/zellij-\u0026lt;UID\u0026gt;/zellij-log/zellij.log or in macOS somewhere in /var/folders/.../zellij-log/zellij.log.\nNow let\u0026rsquo;s add the following lines to the code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fn update(\u0026amp;mut self, event: Event) -\u0026gt; bool { let mut should_render = false; match event { Event::ModeUpdate(mode_info) =\u0026gt; { + eprintln!(\u0026#34;Mode update\u0026#34;); let mode = format!(\u0026#34;{:?}\u0026#34;, mode_info.mode); let count = self.mode_log.entry(mode).or_insert(0); *count += 1; should_render = true; } Event::TabUpdate(tab_info) =\u0026gt; { + eprintln!(\u0026#34;Tab update\u0026#34;); self.tabs = tab_info.iter().map(|t| t.name.clone()).collect(); should_render = true; } Event::Key(key) =\u0026gt; { + eprintln!(\u0026#34;Key\u0026#34;); if let Key::Char(\u0026#39;n\u0026#39;) = key { self.test_runs += 1; open_command_pane_floating(CommandToRun { path: \u0026#34;cargo\u0026#34;.into(), args: vec![\u0026#34;test\u0026#34;.to_owned()], cwd: None, }); } } _ =\u0026gt; (), }; should_render } When the plugin is now recompiled and loaded, we should see the log output in the Zellij log file. This approach can be used to easily debug and understand the plugin logic. However, it is not recommended to use this logging in a production plugin, since you normally don\u0026rsquo;t read them. For a more advanced approach, please read the tracing section in Common Snippets.\nFurther steps After playing around with the example plugin, you can start developing your own plugin. For a complete API reference, please refer to https://docs.rs/zellij-tile/latest/zellij_tile/.\n","permalink":"https://blog.nerd.rocks/posts/getting-started-with-zellij-plugins/","summary":"\u003cp\u003eThis guide will help you get started with developing a plugin for Zellij in Rust. It will guide you through\nsetting up your development environment, creating a new plugin, and playing around to understand how\nZellij plugins work.\u003c/p\u003e\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\u003cp\u003eMake sure you have the following programs installed on your system:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRust with the wasm32-wasi target \u003cem\u003eor\u003c/em\u003e rustup\u003c/li\u003e\n\u003cli\u003eZellij\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you have installed rustup, you can install the wasm32-wasi target by running:\u003c/p\u003e","title":"Getting started with developing Zellij plugins"},{"content":"Zellij is a terminal multiplexer written in Rust, that aims to provide an intuitive and easy to extend working environment. With version 0.37.0 Zellij introduced a plugin system, that allows users to write plugins with WebAssembly. Additionally the plugin system provides a rust crate with an API to interact with the Zellij core.\nSince zellij to the date of writing this article has not provided customizations for the status bar, I decided to write one that is easily customizable by writing KDL configuration into layout files - zjstatus.\nWhile writing, extending and refactoring the plugin, I learned a lot about the plugin system, WebAssembly and Rust in general. Especially about performance impact in Rust when memory management is not implemented correctly. In this article I want to share some of these insights.\nIn order to follow the article, please check out the official rust-plugin-example, which I used as a starting point.\nInitial setup This section describes some actions I took to set up the development environment for simplifying the development process.\nDevelopment dependencies Since I\u0026rsquo;m a big fan of nix and nixOS, I started by creating a shell.nix file, that provides all the dependencies needed for development. It contains a pinned version of the nixpkgs repository, that holds build instructions for used dependencies and their respective versions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 { pkgs ? import \u0026lt;nixpkgs\u0026gt; {} }: with pkgs; let pinnedPkgs = fetchFromGitHub { owner = \u0026#34;NixOS\u0026#34;; repo = \u0026#34;nixpkgs\u0026#34;; rev = \u0026#34;a63a64b593dcf2fe05f7c5d666eb395950f36bc9\u0026#34;; sha256 = \u0026#34;sha256-+ZoAny3ZxLcfMaUoLVgL9Ywb/57wP+EtsdNGuXUJrwg=\u0026#34;; }; pkgs = import pinnedPkgs {}; inherit (lib) optional optionals; inherit (darwin.apple_sdk.frameworks) Cocoa CoreGraphics Foundation IOKit Kernel OpenGL Security; in pkgs.mkShell rec { buildInputs = with pkgs; [ clang # Replace llvmPackages with llvmPackages_X, where X is the latest LLVM version (at the time of writing, 16) llvmPackages.bintools rustup libiconv watchexec ]; RUSTC_VERSION = pkgs.lib.readFile ./rust-toolchain; # https://github.com/rust-lang/rust-bindgen#environment-variables LIBCLANG_PATH = pkgs.lib.makeLibraryPath [ pkgs.llvmPackages_latest.libclang.lib ]; shellHook = \u0026#39;\u0026#39; export PATH=$PATH:\u0026#39;\u0026#39;${CARGO_HOME:-~/.cargo}/bin export PATH=$PATH:\u0026#39;\u0026#39;${RUSTUP_HOME:-~/.rustup}/toolchains/$RUSTC_VERSION-x86_64-unknown-linux-gnu/bin/ \u0026#39;\u0026#39;; # Add precompiled library to rustc search path RUSTFLAGS = (builtins.map (a: \u0026#39;\u0026#39;-L ${a}/lib\u0026#39;\u0026#39;) [ # add libraries here (e.g. pkgs.libvmi) ]); # Add glibc, clang, glib and other headers to bindgen search path BINDGEN_EXTRA_CLANG_ARGS = # Includes with normal include path (builtins.map (a: \u0026#39;\u0026#39;-I\u0026#34;${a}/include\u0026#34;\u0026#39;\u0026#39;) [ # add dev libraries here (e.g. pkgs.libvmi.dev) pkgs.libiconv ]) # Includes with special directory paths ++ [ \u0026#39;\u0026#39;-I\u0026#34;${pkgs.llvmPackages_latest.libclang.lib}/lib/clang/${pkgs.llvmPackages_latest.libclang.version}/include\u0026#34;\u0026#39;\u0026#39; \u0026#39;\u0026#39;-I\u0026#34;${pkgs.libiconv.out}/lib/\u0026#34;\u0026#39;\u0026#39; ]; } It will install clang, llvm, rustup, libiconv and watchexec into a nix shell, additionally to configure build dependencies for the rust compiler. To automatically enable usage of these dependencies, I added a .envrc to utilze direnv for automatically loading the nix shell when entering the project directory.\n1 use nix Later on I switched to a flake.nix file to provide a convenient, reproducible and declarative way to build the project.\nTask runner Even if most of the tasks while developing can be done by directly running cargo commands, I start by setting up a justfile, that is used by just, an alternative to make. Then justfile will provide a unified interface to run all the commands needed for development and also lists them conveniently.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 build: cargo build run: build zellij -l ./plugin-dev-workspace.kdl -s zjstatus-dev test: cargo component test -- --nocapture lint: cargo clippy --all-targets -- -D warnings cargo audit release version: cargo set-version {{version}} direnv exec . cargo build --release git commit -am \u0026#34;chore: bump version to v{{version}}\u0026#34; git tag -m \u0026#34;v{{version}}\u0026#34; v{{version}} git cliff --current Commands can be run by calling just \u0026lt;command\u0026gt;, e.g. just run. The syntax for releases allows to bump the version and create a git tag with a single command: just release 0.1.0.\nSplitting code to binary and library As we want to write tests and benchmarks for the code, we need to split the entrypoint of the plugin from the library code. All parts that we want to test and benchmark need to be part of the library crate. To split the binary from the library, we need to modify the file structure in the following way:\n1 2 src/main.rs -\u0026gt; src/bin/plugin-name.rs # move src/lib.rs # create The current main file will be moved to src/bin/plugin.rs and the src/lib.rs file will be created. src/lib.rs will contain the library code, that contains logic for the plugin. In addition to the directory structure, we need to modify the Cargo.toml file to reflect the changes:\n1 2 3 4 5 6 [[bin]] name = \u0026#34;plugin-name\u0026#34; bench = false [lib] bench = false This will prevent cargo from directly running library or binary code, when only benchmarks should be run. It is important to configure the project like that because zellij\u0026rsquo;s API with register_plugin will try to connect to the running zellij instance, which is not present when running benchmarks. Since all logic related code is now located in the library, we need to import it in the binary or benchmarks with use plugin_name::*;.\nUnit testing For ensuring the correctness of plugin logic and to validate, that the logic works as expected when refactoring the code, I am a big fan of unit testing. It not only helps to ensure correctness, but also provides a way to document the code and its usage. In addition it helps to develop new features in a test driven way, such that the test is written before the actual implementation.\nUnit tests in zellij plugins can be written by adding a #[cfg(test)] attribute to the test module and writing tests with the #[test] attribute - like in any other rust project. You just need to make sure, that code that interacts with zellij\u0026rsquo;s API is not executed when running tests, as it will fail otherwise. This can be done by using the #[cfg(not(test))] attribute on the code that should not be executed when running tests.\nAnother tricky part is to run the unit tests, as they need to be run within a WebAssembly runtime (like wasmtime). To simplify running the tests, I added cargo-component to the project dependencies, which runs code with wasmtime after it has been compiled. A shortcut for running the tests was also added to the justfile before.\nHere\u0026rsquo;s an example of a unit test, that verifies the correctness of the parse_color function:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #[cfg(test)] mod test { use super::*; #[test] fn test_parse_color() { let result = parse_color(\u0026#34;#010203\u0026#34;); let expected = RgbColor(1, 2, 3); assert_eq!(result, Some(expected.into())); let result = parse_color(\u0026#34;255\u0026#34;); let expected = Ansi256Color(255); assert_eq!(result, Some(expected.into())); let result = parse_color(\u0026#34;365\u0026#34;); assert_eq!(result, None); let result = parse_color(\u0026#34;#365\u0026#34;); assert_eq!(result, None); } } Benchmarks Benchmarks can be used to check for performance regressions when refactoring code. They can also be used to measure the performance impact of new features. Therefore it is important to store results of the benchmarks, to compare them with future runs.\nNormally, I like to use divan for writing benchmarks, but it does not support WebAssembly yet. Therefore I switched to criterion since it supports WebAssembly and provides some convenient features for storing and comparing benchmark results.\nTo start with benchmarks, first add criterion and the benchmark targets to the Cargo.toml file:\n1 2 3 4 5 6 [dev-dependencies] criterion = { version = \u0026#34;0.5.1\u0026#34;, default-features = false, features = [\u0026#34;html_reports\u0026#34;] } [[bench]] name = \u0026#34;benches\u0026#34; harness = false Benchmark targets must be named like the benchmark files in the benches directory, e.g. benches/benches.rs.\nFollow the criterion documentation for writing benchmarks. Here\u0026rsquo;s a quick example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 use criterion::{criterion_group, criterion_main, Criterion}; use zjstatus::render::formatted_parts_from_string_cached; fn bench_formattedparts_from_format_string_cached(c: \u0026amp;mut Criterion) { c.bench_function(\u0026#34;formatted_parts_from_string_cached\u0026#34;, |b| { b.iter(|| { formatted_parts_from_string_cached( \u0026#34;#[fg=#9399B2,bg=#181825,bold,italic] {index} {name} [] #[fg=#9399B2,bg=#181825,bold,italic] {index} {name} [] \u0026#34;, ) }) }); } fn criterion_benchmark(c: \u0026amp;mut Criterion) { bench_formattedparts_from_format_string_cached(c); } criterion_group!(benches, criterion_benchmark); criterion_main!(benches); Similar to unit tests we need to make sure that code which interacts with zellij\u0026rsquo;s API is not executed when running benchmarks. Therefore we need to add a new feature to the Cargo.toml and add the #[cfg(not(feature = \u0026quot;bench\u0026quot;))] attribute to the code that should not be executed when running benchmarks.\n1 2 [features] bench = [] Since criterion needs to store benchmark results in the target directory, we cannot run benchmarks with cargo component bench. cargo component bench will not only try to run the plugin wasm binary outside of zellij, but also runs the benchmarks in wasmtime without granting permissions to write to the target directory. Therefore we need to compile benchmarks with cargo bench --target wasm32-wasi --benches --no-run --feature=benches. After compilation it will print the path to the compiled binaries. These binaries then must be executed with wasmtime and the --dir flag to grant permissions to write to the target directory. The following target in the justfile will automate this process:\n1 2 3 4 5 6 bench: #!/usr/bin/env bash benchmarks=\u0026#34;$(cargo bench --target wasm32-wasi --features=bench --no-run --color=always 2\u0026gt;\u0026amp;1 | tee /dev/tty | grep -oP \u0026#39;target/.*.wasm\u0026#39;)\u0026#34; echo \u0026#34;$benchmarks\u0026#34; \\ | xargs -I{} wasmtime --dir $PWD/target::target {} --bench --color=always Since the benchmarks are now able to store the json results in the target directory, criterion is able to compare the result with previous runs.\nThis technique allowed me to improve the performance of zjstatus a lot, after I learned how to better utilize the borrow checker and be aware of memory allocations. To improve performance, I tried to avoid .clone() calls where possible and instead use references, since references are cheap to copy, whereas .clone() needs to allocate memory of the size of the cloned object and copy the data.\n","permalink":"https://blog.nerd.rocks/posts/profiling-zellij-plugins/","summary":"\u003cp\u003eZellij is a terminal multiplexer written in Rust, that aims to provide an intuitive and easy to extend working environment.\nWith version 0.37.0 Zellij introduced a plugin system, that allows users to write plugins with WebAssembly.\nAdditionally the plugin system provides a rust crate with an API to interact with the Zellij core.\u003c/p\u003e\n\u003cp\u003eSince zellij to the date of writing this article has not provided customizations for the status bar, I decided to write one that is easily customizable by writing KDL configuration into layout files - \u003ca href=\"https://github.com/dj95/zjstatus\"\u003ezjstatus\u003c/a\u003e.\u003c/p\u003e","title":"Learnings from developing a zellij plugin"},{"content":"SameSite cookies are commonly used to harden websites against CSRF attacks. These attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with the SameSite attribute set to strict should not be send to the destination site, if the request passed a foreign site. However, handling of the SameSite attribute differs between Firefox and Chromium.\nWhat is the SameSite attribute in theory? The SameSite attribute was specified in the RFC draft rfc6265bis. It can be used with three different enforcement modes RFC6265bis#section-5.5.7.1: none, strict and lax.\nnone disables the SameSite enforcement such that cookies are also sent when the request is invoked by a cross site. strict enforces the cookie only to be sent when it is a same site request. Therefore the cookie is only sent, when the site was requested by entering the url manually in the url bar of the browser or navigating on the same domain. lax is not as strict as the strict mode since it allows to sent cookies in a request that is invoked by a cross site when it uses a safe http method. Http methods are considered safe if their semantic is defined as read-only (RFC7231#section-4.2.1). In order to separate a same site request from a cross site request, the RFC introduces an algorithm in section 5.2. To conclude the algorithm, one can say, that every request, that is not initiated by hand(by entering the url manually) or by the exact match of the referring domain, is cross site. Every other request is a same site request.\nPractical behavior in Firefox and Chromium For testing the behavior of Firefox and Chromium I\u0026rsquo;ve implemented a website, that sets three cookies, is able to display them and is able to redirect manually, as well as automatically. Each of three cookies have the SameSite attribute set to none, lax and strict. The website is able to perform the role of both sites, since it is able to perform the redirect on both ways. Therefore the application will be started twice in a docker container with a static ip address: 10.5.0.2 and 10.5.0.3. This is important since it enforces another target address for the redirect.\nAfter starting the docker container, we are able to open the first site in our first browser we are testing - Firefox 110.0.1 on linux. Then we click on \u0026ldquo;Set the cookies\u0026rdquo; in order to set all three cookies. As one can see in the screenshot, they are set correctly. Next to Firefox you are also able to see, that they are set in Chromium 111.0.5563.64 on linux.\nNext we click on \u0026ldquo;Invoke manual redirect for testing\u0026rdquo; in both browsers. This will redirect the browser to 10.5.0.3. There we do not see any cookies, as we did not set them. If we then click on \u0026ldquo;Invoke manual redirect for testing\u0026rdquo; again, we are redirected back to 10.5.0.2 and are able to see only the cookies without the SameSite-attribute set to strict, which behaves exactly like the RFC described it before.\nIn our next test we will perform an automatic redirect. To reset the scenario, we click on \u0026ldquo;Delete cookies\u0026rdquo; and \u0026ldquo;Set the cookies\u0026rdquo;, which leads to the same page as in the first screenshot. After resetting the scenario, we click on \u0026ldquo;Invoke the redirect for testing\u0026rdquo;. This will automatically redirect to 10.5.0.3 and the back to 10.5.0.2. Hence the algorithm for determining a same site request states out that every URL in the redirect must be the same as the origin for a same site request, we expect to not see the cookie with the SameSite-attribute set to strict as well. However, Chromium is sending the cookie along with the request. Firefox, in contrast, is behaving correctly.\nPotential attack surface Some sites allow users to be redirected by a given URL as a query parameter, e.g. when you enter the URL to a restricted area without authentication and the destination URL is stored as a query parameter on the login page. If these redirects are used, even if they are bad practice, and allow redirects to external sites, cookies with SameSite set to strict will not mitigate CSRF attacks in Chromium.\nIn detail, an attacker would the an example URL to the victim like https://vuln.erable/login?to=https://att.acker. This would show the login site of the vulnerable site to the victim, who then enters the credentials. The vulnerable site then sends the cookie containing the session with SameSite set to strict back to the browser and invokes then the redirect to the attacking site via HTTP- or JS- redirect. The attacking site will then create some malicous redirect, which might extract some information or controls some aspects in the vulnerable site. This redirect is the performed by the browser. Firefox will drop the session cookie due to the SameSite attribute and will therefore break the session, such that the exploit would be mitigated in the first place. Chromium however will not drop the session cookie as shown in the lab setup before. Therefore the exploit would be successful.\nConclusion Firefox and Chromium handle the SameSite attribute with enforcment mode strict quite different in terms of redirects. On automatic redirects, Chromium will not drop the cookie, in contrast to the specification. However, the potential attack surface is quite limited and requires bad practices and other flaws in the web application. Therefore one should be aware of the different behavior and not only rely on a single countermeasure against certain attacks. The mitigation should always be validated in certain scenarios.\n","permalink":"https://blog.nerd.rocks/posts/state-of-samesite-in-firefox-and-chrome/","summary":"\u003cp\u003eSameSite cookies are commonly used to harden websites against CSRF attacks.\nThese attacks can be mitigated in certain scenarios with SameSite cookies, since a cookie with\nthe SameSite attribute set to \u003cem\u003estrict\u003c/em\u003e should not be send to the destination\nsite, if the request passed a foreign site. However, handling of the SameSite\nattribute differs between Firefox and Chromium.\u003c/p\u003e\n\u003ch3 id=\"what-is-the-samesite-attribute-in-theory\"\u003eWhat is the SameSite attribute in theory?\u003c/h3\u003e\n\u003cp\u003eThe SameSite attribute was specified in the RFC draft \u003ca href=\"https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-11\"\u003erfc6265bis\u003c/a\u003e.\nIt can be used with three different enforcement modes \u003ca href=\"https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-11#name-strict-and-lax-enforcement\"\u003eRFC6265bis#section-5.5.7.1\u003c/a\u003e: \u003cem\u003enone\u003c/em\u003e, \u003cem\u003estrict\u003c/em\u003e and \u003cem\u003elax\u003c/em\u003e.\u003c/p\u003e","title":"State of SameSite cookies in Firefox and Chromium"},{"content":"In the last blog article I described a way how to debug SIGABRT crashes in neovim with the help of a nix shell. It helped me to find out the cause of the crashes in neovim 0.5.0 and an already existing issue in the github project, which already provided a solution. Unfortunately, since a few weeks, I experience crashes in neovim again. Most of the time when using telescope with the preview, neovim randomly crashes. However, when running :checkhealth, the crash occurs in the same way.\nIn order to debug the issue, the first approach would be to check the Console application since I\u0026rsquo;m using macOS. The stacktrace from Console should provide enough information to find the root cause of the crashes. Unlike the last error that cause SIGABRT crashes, the stacktrace does not useful information, as the following screenshot depicts.\nThis requires another approach to find out more debug information. For this, I\u0026rsquo;ve created another shell.nix with the current version of neovim and a debugging build of the current released version and the latest nightly version. Since the error also occurs in the nightly version, debugging in it is more useful since it simplifies contributing a fix to the neovim project. The following shell.nix will compile the current nightly on macOS.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { pkgs ? import \u0026lt;nixpkgs\u0026gt; { overlays = [ (self: super: { neovim-dev = (super.pkgs.neovim-unwrapped.override {}).overrideAttrs(oa:{ # use the latest stable neovim version = \u0026#34;master\u0026#34;; src = pkgs.fetchFromGitHub { owner = \u0026#34;neovim\u0026#34;; repo = \u0026#34;neovim\u0026#34;; rev = \u0026#34;master\u0026#34;; sha256 = \u0026#34;YfPM6yjKWu4RPAtLefggWC0ZOGgbcPsk6VT5M3D41B0=\u0026#34;; }; # use the debug type to enable debug symbols cmakeBuildType=\u0026#34;debug\u0026#34;; buildInputs = super.pkgs.neovim-unwrapped.buildInputs ++ [ pkgs.darwin.apple_sdk.frameworks.CoreServices ]; shellHook = \u0026#39;\u0026#39; export NVIM_PYTHON_LOG_LEVEL=DEBUG export NVIM_LOG_FILE=/tmp/log \u0026#39;\u0026#39;; }); }) ]; }}: pkgs.mkShell { nativeBuildInputs = with pkgs; [ neovim-dev ]; } Starting neovim with nvim -u NONE for starting with an empty config and running the healthcheck will result in the SIGABRT again. Since the debugging build does not provide a stacktrace with more information, we need to use lldb, a debugger on macOS, to further find the cause. Therefore we need to start the process with lldb nvim. This starts lldb with nvim as target and provides an interactive shell.\nStarting neovim with run (or r if you\u0026rsquo;re lazy like me) will execute neovim and we are able to reproduce the crash again. After neovim crashes, lldb provides short trace where the program actually crashed. Since we want to analyze the complete stacktrace, we need to run bt, which provides a complete stacktrace, that is depicted in the following screenshot.\nAnalyzing the stacktrace, we are able to examine the last function in neovim, that was executed: nvim'tslua_add_language. This function can be found in a file called treesitter.c and is responsible for the treesitter integration. Due to the name of the function and its content, we can examine, that it loads configured and already existing parsers.\nWhen we further anlyze the stacktrace and watch out for functions that do not belong to the standard libraries, we are able to find the markdown.so'_GLOBAL__sub_I_scanner.c. It provides a hint to the markdown treesitter parser, which actually consists of a scanner.cc file.\nIn order to test, if the parser causes the crashes, we uninstall it with :TSUninstall markdown and the run :checkhealth agian. Suprisingly, neovim does not cash anymore! As a quick fix, we can now remove the parser from the configuration and neovim should (hopefully) run stable again.\n","permalink":"https://blog.nerd.rocks/posts/debugging-another-sigabrt-in-neovim/","summary":"\u003cp\u003eIn the last blog article I described a way how to debug SIGABRT crashes in neovim with the help of a nix shell.\nIt helped me to find out the cause of the crashes in neovim 0.5.0 and an already existing issue in the github project, which already provided a solution.\nUnfortunately, since a few weeks, I experience crashes in neovim again.\nMost of the time when using telescope with the preview, neovim randomly crashes.\nHowever, when running \u003ccode\u003e:checkhealth\u003c/code\u003e, the crash occurs in the same way.\u003c/p\u003e","title":"Debugging another SIGABRT in neovim"},{"content":"Since the introduction of the new lua api in neovim 0.5.0 there are plenty new vim plugins based on this api. While testing some of the new plugins, my neovim exited with a SIGSEGV and sometime with a SIGABRT in specific workflows. As these crashes are reproducible, it should be easy to debug the problem. However, we need a debug build of neovim and, since I\u0026rsquo;m using macOS, the stack trace of neovim.\nmacOS offers an application called Console, which captures and stores all stack traces of crashed applications. After opening the application, we should find the neovim crashes under the Crash Reports tab.\nDepending on the installation, these crash reports might already contain debug symbols which allows me to examine the root cause. If this is not the case or you want to dig deeper and step through neovim with a debugger, to completely understand the root cause and not only the function in which the error occurs, you need a debug build of neovim.\nSince I do not want to use the debug build as my daily driver and simplify the build process to quickly spin up a debug build in case another error occurs, I utilize nix. Nix enables a declarative way to specify installed packages and allows me to override attributes in these packages. In addition, with nix these packages can be accesses in a separate shell environment instead of installing them in the $PATH of the system.\nFor this shell, a shell.nix file is required, that specifies the required environment. Hence I want to debug neovim, it contains the installation candidate for neovim. However, the neovim package is extended and configured with an overlay. This overlay overrides the version of neovim and enables the debugging build with cmakeBuildType=\u0026quot;debug\u0026quot;. The following code block depicts the shell.nix that can be used to debug neovim.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 { pkgs ? import \u0026lt;nixpkgs\u0026gt; { overlays = [ (self: super: { neovim-dev = (super.pkgs.neovim-unwrapped.override {}).overrideAttrs(oa:{ # use the latest stable neovim version = \u0026#34;0.5.0\u0026#34;; src = pkgs.fetchFromGitHub { owner = \u0026#34;neovim\u0026#34;; repo = \u0026#34;neovim\u0026#34;; rev = \u0026#34;v0.5.0\u0026#34;; sha256 = \u0026#34;0aXo8f1YGEI8PkLDOSgxqQy7qK031R+eapCppUFy61E\u0026#34;; }; # use the debug type to enable debug symbols cmakeBuildType=\u0026#34;debug\u0026#34;; shellHook = \u0026#39;\u0026#39; export NVIM_PYTHON_LOG_LEVEL=DEBUG export NVIM_LOG_FILE=/tmp/log \u0026#39;\u0026#39;; }); }) ]; }}: pkgs.mkShell { nativeBuildInputs = [ pkgs.neovim-dev ]; } When nix-shell is exexuted in the same directory as the preceeding shell.nix, neovim will be built with the specified configuration. To verify that nix-shell build the debug vesion, nvim --version should show debug as the build type.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ nvim --version NVIM v0.5.1 Build type: Release LuaJIT 2.1.0-beta3 Compilation: Compiled by _nixbld1 $ nix-shell # ... some build output [nix-shell] $ nvim --version NVIM v0.5.1 Build type: debug LuaJIT 2.1.0-beta3 Compilation: Compiled by daniel ","permalink":"https://blog.nerd.rocks/posts/debugging-with-nix-shell/","summary":"\u003cp\u003eSince the introduction of the new lua api in neovim 0.5.0 there are plenty new vim plugins based on this api.\nWhile testing some of the new plugins, my neovim exited with a \u003ccode\u003eSIGSEGV\u003c/code\u003e and sometime with a \u003ccode\u003eSIGABRT\u003c/code\u003e in specific workflows.\nAs these crashes are reproducible, it should be easy to debug the problem.\nHowever, we need a debug build of neovim and, since I\u0026rsquo;m using macOS, the stack trace of neovim.\u003c/p\u003e","title":"Debugging neovim with nix shell"}]